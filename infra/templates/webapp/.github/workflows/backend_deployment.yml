name: Deploy Backend to Yandex Serverless Containers

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/backend_deployment.yml'

jobs:
  deploy:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Yandex Container Registry
        uses: docker/login-action@v3
        with:
          registry: cr.yandex
          username: json_key
          password: ${{ secrets.YC_SA_JSON_CREDENTIALS }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: cr.yandex/${{ secrets.YC_REGISTRY_ID }}/${{ secrets.YC_CONTAINER_NAME }}:${{ github.sha }},cr.yandex/${{ secrets.YC_REGISTRY_ID }}/${{ secrets.YC_CONTAINER_NAME }}:latest
          cache-from: type=registry,ref=cr.yandex/${{ secrets.YC_REGISTRY_ID }}/${{ secrets.YC_CONTAINER_NAME }}:latest
          cache-to: type=inline

      - name: Install Yandex Cloud CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
          echo "$HOME/yandex-cloud/bin" >> $GITHUB_PATH

      - name: Setup Yandex Cloud credentials
        run: |
          echo '${{ secrets.YC_SA_JSON_CREDENTIALS }}' > sa-key.json
          $HOME/yandex-cloud/bin/yc config profile create sa-profile
          $HOME/yandex-cloud/bin/yc config set service-account-key sa-key.json
          $HOME/yandex-cloud/bin/yc config set folder-id ${{ secrets.YC_FOLDER_ID }}

      - name: Extract static files from Docker image
        run: |
          docker create --name temp_static_container cr.yandex/${{ secrets.YC_REGISTRY_ID }}/${{ secrets.YC_CONTAINER_NAME }}:${{ github.sha }}
          docker cp temp_static_container:/app/staticfiles ./backend_static
          docker rm temp_static_container
          echo "Static files extracted to ./backend_static"
          ls -R ./backend_static # Optional: list files for debugging

      - name: Create static bucket if not exists
        env:
          BUCKET_NAME: ${{ secrets.YC_STATIC_BUCKET_NAME }}
        run: |
          echo "Attempting to create bucket: ${BUCKET_NAME}"
          $HOME/yandex-cloud/bin/yc storage bucket create "${BUCKET_NAME}" --default-storage-class=standard --acl=public-read || echo "Bucket already exists or failed to create (error ignored)"
          # Note: --acl=public-read makes the bucket contents publicly readable.
          # Adjust ACL or rely on API Gateway SA permissions if needed.

      - name: Upload static files to Yandex Cloud Object Storage
        uses: yc-actions/yc-obj-storage-upload@v2
        with:
          yc-sa-json-credentials: ${{ secrets.YC_SA_JSON_CREDENTIALS }}
          bucket: ${{ secrets.YC_STATIC_BUCKET_NAME }} # Use the new secret for the static bucket
          root: ./backend_static/ # Root directory containing static files
          include: "**/*"
          prefix: "static/" # Upload files under the 'static/' prefix in the bucket
          # Set appropriate cache headers for static files
          cache-control: |
            *.js, *.css: public, max-age=31536000, immutable
            *.png, *.jpg, *.jpeg, *.gif, *.svg, *.ico: public, max-age=31536000
            *: public, max-age=3600

      - name: Prepare Allowed Hosts
        id: prepare_hosts
        env:
          YC_API_GATEWAY_NAME: ${{ secrets.YC_API_GATEWAY_NAME }}
          SECRET_ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
        run: |
          echo "Checking for existing API Gateway: ${YC_API_GATEWAY_NAME}"
          API_GW_URL=$($HOME/yandex-cloud/bin/yc serverless api-gateway get --name "${YC_API_GATEWAY_NAME}" --format json 2>/dev/null | jq -r '.domain // empty')

          FINAL_ALLOWED_HOSTS="${SECRET_ALLOWED_HOSTS}"

          if [[ -n "$API_GW_URL" ]]; then
            echo "API Gateway found with URL: ${API_GW_URL}"
            if [[ -n "$FINAL_ALLOWED_HOSTS" ]]; then
              # Add gateway URL with comma if SECRET_ALLOWED_HOSTS is not empty
              FINAL_ALLOWED_HOSTS="${API_GW_URL},${FINAL_ALLOWED_HOSTS}"
            else
              # Use only gateway URL if SECRET_ALLOWED_HOSTS is empty
              FINAL_ALLOWED_HOSTS="${API_GW_URL}"
            fi
          else
            echo "API Gateway not found or no domain returned. Using SECRET_ALLOWED_HOSTS."
          fi

          echo "Final ALLOWED_HOSTS for deployment: ${FINAL_ALLOWED_HOSTS}"
          echo "::set-output name=dynamic_hosts::${FINAL_ALLOWED_HOSTS}"

      - name: Deploy to Yandex Serverless Containers
        env:
          YC_CONTAINER_NAME: ${{ secrets.YC_CONTAINER_NAME }}
          YC_REGISTRY_ID: ${{ secrets.YC_REGISTRY_ID }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          YC_SERVICE_ACCOUNT_ID: ${{ secrets.YC_SERVICE_ACCOUNT_ID }}
          YC_NETWORK_ID: ${{ secrets.YC_NETWORK_ID }}
        run: |
          # Создаем или обновляем контейнер
          $HOME/yandex-cloud/bin/yc serverless container revisions deploy \
            --container-name "${YC_CONTAINER_NAME}" \
            --image "cr.yandex/${YC_REGISTRY_ID}/${YC_CONTAINER_NAME}:${{ github.sha }}" \
            --folder-id "${YC_FOLDER_ID}" \
            --memory 1GB \
            --cores 1 \
            --concurrency 8 \
            --execution-timeout 60s \
            --network-id "${YC_NETWORK_ID}" \
            --environment DJANGO_SETTINGS_MODULE=project.settings \
            --environment DATABASE_URL="${DATABASE_URL}" \
            --environment SECRET_KEY="${DJANGO_SECRET_KEY}" \
            --environment ALLOWED_HOSTS="${{ steps.prepare_hosts.outputs.dynamic_hosts }}" \
            --environment DEBUG=False \
            --environment CORS_ALLOWED_ORIGINS="${CORS_ALLOWED_ORIGINS}" \
            --service-account-id "${YC_SERVICE_ACCOUNT_ID}"

          # Получаем URL контейнера
          CONTAINER_URL=$($HOME/yandex-cloud/bin/yc serverless container get "${YC_CONTAINER_NAME}" --format json | jq -r '.url')
          echo "Deployed container URL: $CONTAINER_URL"

          # Сохраняем URL контейнера для использования в следующих шагах
          echo "CONTAINER_URL=$CONTAINER_URL" >> $GITHUB_ENV

          echo "Миграции запускаются автоматически при старте контейнера через entrypoint.sh"
          echo "Ожидаем 10 секунд, чтобы контейнер инициализировался и запустил миграции..."
          sleep 10

      - name: Update or Create API Gateway
        env:
          YC_CONTAINER_NAME: ${{ secrets.YC_CONTAINER_NAME }}
          YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
          YC_API_GATEWAY_NAME: ${{ secrets.YC_API_GATEWAY_NAME }}
          YC_SERVICE_ACCOUNT_ID: ${{ secrets.YC_SERVICE_ACCOUNT_ID }}
        run: |
          # Получаем ID ревизии контейнера
          CONTAINER_ID=$($HOME/yandex-cloud/bin/yc serverless container get "${YC_CONTAINER_NAME}" --format json | jq -r '.id')

          # Создаем временный файл спецификации API Gateway
          cat > api-gw-spec.yaml << EOF
          openapi: 3.0.0
          info:
            title: Django Backend API
            version: 1.0.0
          paths:
            /static/{proxy+}: # Route for static files
              get: # Explicitly use GET method for static files
                parameters:
                  - name: proxy
                    in: path
                    required: true
                    schema:
                      type: string
                x-yc-apigateway-integration:
                  type: object_storage
                  bucket: "${{ secrets.YC_STATIC_BUCKET_NAME }}" # Bucket with static files
                  object: "static/{proxy}" # Map URL path to object key including prefix
                  presigned_redirect: false # Serve files directly
                  # service_account_id: "${YC_SERVICE_ACCOUNT_ID}" # Uncomment if bucket access requires SA
            /: # Route for root path to container
              get:
                x-yc-apigateway-integration:
                  type: serverless_containers
                  container_id: $CONTAINER_ID
                  service_account_id: "${YC_SERVICE_ACCOUNT_ID}"
              post:
                x-yc-apigateway-integration:
                  type: serverless_containers
                  container_id: $CONTAINER_ID
                  service_account_id: "${YC_SERVICE_ACCOUNT_ID}"
            /{path+}: # Catch-all for other paths to container
              x-yc-apigateway-any-method:
                parameters:
                  - name: path
                    in: path
                    required: true
                    schema:
                      type: string
                x-yc-apigateway-integration:
                  type: serverless_containers
                  container_id: $CONTAINER_ID
                  service_account_id: "${YC_SERVICE_ACCOUNT_ID}"
          EOF

          # Проверяем, существует ли API Gateway
          API_GATEWAY_EXISTS=$($HOME/yandex-cloud/bin/yc serverless api-gateway list --format=json | jq -r --arg name "${YC_API_GATEWAY_NAME}" '.[] | select(.name==$name) | .id')

          if [ -z "$API_GATEWAY_EXISTS" ]; then
            echo "API Gateway '${YC_API_GATEWAY_NAME}' не существует, создаем..."
            $HOME/yandex-cloud/bin/yc serverless api-gateway create \
              --name "${YC_API_GATEWAY_NAME}" \
              --spec api-gw-spec.yaml \
              --folder-id "${YC_FOLDER_ID}"
          else
            echo "API Gateway '${YC_API_GATEWAY_NAME}' существует, обновляем..."
            $HOME/yandex-cloud/bin/yc serverless api-gateway update "${YC_API_GATEWAY_NAME}" \
              --spec api-gw-spec.yaml \
              --folder-id "${YC_FOLDER_ID}"
          fi

          # Получаем URL API Gateway
          API_GW_URL=$($HOME/yandex-cloud/bin/yc serverless api-gateway get "${YC_API_GATEWAY_NAME}" --format json | jq -r '.domain')
          echo "API Gateway URL: $API_GW_URL"

          # Сохраняем URL API Gateway для использования в следующих шагах
          echo "API_GW_URL=$API_GW_URL" >> $GITHUB_ENV

      - name: Health check
        run: |
          echo "Проверяем доступность сервиса через API Gateway: https://$API_GW_URL"

          # Пробуем получить ответ от сервиса
          MAX_RETRIES=10
          COUNT=0
          while [ $COUNT -lt $MAX_RETRIES ]; do
            # Проверяем эндпоинт /health/
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$API_GW_URL/health/")

            if [ "$HTTP_STATUS" = "200" ]; then
              echo "Сервис запущен и готов к работе!"
              break
            else
              echo "Получен статус $HTTP_STATUS, ожидаем готовности сервиса... (${COUNT}/${MAX_RETRIES})"
              sleep 5
              COUNT=$((COUNT+1))
            fi
          done

          if [ $COUNT -eq $MAX_RETRIES ]; then
            echo "Сервис не запустился после $MAX_RETRIES попыток!"
            exit 1
          fi